{"version":3,"sources":["webpack:///./src/views/RectCollisionDemo.vue?8435","webpack:///./src/views/RectCollisionDemo.vue","webpack:///./src/models/ScreenRect.ts","webpack:///./src/views/RectCollisionDemo.vue?76bf","webpack:///./src/views/RectCollisionDemo.vue?057f"],"names":["ref","class","width","height","new_rectangle","location","velocity","bounding_box","fill_color","Color","create_random","ctx","fillStyle","this","rgba","fillRect","collision_box","x","y","p","speed","atan2","Math","Point","sin","cos","Rect","centered_at","Sprite","selected_rect","bound_handlers","mousemove","handle_mousemove","bind","mouseup","handle_mouseup","mousedown","handle_mousedown","sprites","push","rectangles","create_rectangle","origin","viewport","canvas","center","color","r","copy","null_rect","did_leave_bounding_box","dt","collisions","length","i","j","c_rect","intersection","event","preventDefault","stopPropagation","container","target","pageX","offsetLeft","pageY","offsetTop","get_rect_at","doc","get_root_node","addEventListener","movementX","movementY","removeEventListener","el","constructor","HTMLDocument","parentNode","contains","GameWorld","setup","game_container","game_world","start_game","buffer","setInterval","update","draw","floor","performance","now","clear_canvas","drawImage","requestAnimationFrame","clearRect","random","rectangle","value","game_canvas","querySelector","document","createElement","getContext","render","__scopeId"],"mappings":"gHAAA,W,+JCCOA,IAAI,iBAAiBC,MAAM,qB,GACzBA,MAAM,iB,EAGX,eAEM,OAFDA,MAAM,eAAa,CACtB,eAAmC,UAA3BC,MAAM,MAAMC,OAAO,U,2EAL/B,eAOM,MAPN,EAOM,CANJ,eAEM,MAFN,EAEM,CADJ,eAA+E,UAAvEF,MAAM,oBAAqB,QAAK,8BAAE,EAAAG,cAAA,sBAAe,mBAE3D,G,wJCAiB,E,wDAKnB,WAAYC,EAAgBC,EAAqBJ,EAAcC,EAAeI,GAAiB,oCAC7F,cAAMF,EAAUC,EAAUC,GAL5B,EAAAC,WAAoBC,EAAA,KAAMC,gBAMxB,EAAKR,MAAQA,EACb,EAAKC,OAASA,EAH+E,E,2DAUnFQ,GACVA,EAAIC,UAAYC,KAAKL,WAAWM,KAChCH,EAAII,SACFF,KAAKG,cAAcC,EACnBJ,KAAKG,cAAcE,EACnBL,KAAKG,cAAcd,MACnBW,KAAKG,cAAcb,U,8BAIfgB,GAA2B,IAAjBC,EAAiB,uDAAD,EAC5BC,EAAQC,KAAKD,MACfF,EAAEF,EAAIJ,KAAKR,SAASY,EACpBE,EAAED,EAAIL,KAAKR,SAASa,GAMtB,OAJAL,KAAKP,SAAW,IAAIiB,EAAA,KAClBD,KAAKE,IAAIH,GAAOD,EAChBE,KAAKG,IAAIJ,GAAOD,GAEXP,O,oCAtBP,OAAOa,EAAA,KAAKC,YAAYd,KAAKR,SAAUQ,KAAKX,MAAOW,KAAKV,Y,GAZpByB,EAAA,MCMlC,E,wDAAN,iD,0BAEE,EAAAC,cAAiC,KACjC,EAAAC,eAAiB,CACfC,UAAW,EAAKC,iBAAiBC,KAAtB,mBACXC,QAAS,EAAKC,eAAeF,KAApB,mBACTG,UAAW,EAAKC,iBAAiBJ,KAAtB,oBANf,E,qDAYQtB,GACJ,mEAAYA,GACZE,KAAKyB,QAAQC,KAAK,IAClB1B,KAAKyB,QAAQC,KAAK,IAClB1B,KAAKyB,QAAQC,KAAK,IAClB1B,KAAK2B,WAAWD,KAAK1B,KAAK4B,iBAAiB,IAAIlB,EAAA,MAAO,KAAM,KAAM,IAAK,IAAK,IAAId,EAAA,KAAM,EAAE,IAAI,KAC5FI,KAAK2B,WAAWD,KAAK1B,KAAK4B,iBAAiB,IAAIlB,EAAA,KAAM,IAAK,IAAK,IAAK,GAAI,IAAId,EAAA,KAAM,EAAE,EAAE,OACtFI,KAAKyB,QAAQ,GAAGC,KAAK1B,KAAK4B,iBAAiBlB,EAAA,KAAMmB,OAAQ,EAAG,IAAM,IAAIjC,EAAA,KAAM,IAAK,IAAK,EAAG,MACzFI,KAAKyB,QAAQ,GAAGC,KAAK1B,KAAK4B,iBAAiBlB,EAAA,KAAMmB,OAAQ,IAAM,EAAG,IAAIjC,EAAA,KAAM,IAAK,IAAK,EAAG,MACzFI,KAAK8B,SAAW,IAAIjB,EAAA,MACjBf,EAAIiC,OAAO1C,MAAM,GACjBS,EAAIiC,OAAOzC,OAAO,EACnBQ,EAAIiC,OAAO1C,MACXS,EAAIiC,OAAOzC,U,uCAIE0C,EAAc3C,EAAcC,GAAkD,IAAnC2C,EAAmC,uDAArBrC,EAAA,KAAMC,gBACxEqC,EAAI,IAAI,EAAWF,EAAOG,OAAQ,KAAM9C,EAAOC,EAAQuB,EAAA,KAAKuB,WAGlE,OAFAF,EAAEvC,WAAasC,EACfC,EAAEG,uBAAyB,aACpBH,I,wCAGSI,GAChBtC,KAAKuC,WAAWC,OAAS,EACzB,IAAI,IAAIC,EAAI,EAAGA,EAAIzC,KAAK2B,WAAWa,OAAO,EAAGC,IAC3C,IAAI,IAAIC,EAAID,EAAE,EAAGC,EAAI1C,KAAK2B,WAAWa,OAAQE,IAAK,CAChD,IAAMC,EAAS3C,KAAK2B,WAAWc,GAAGtC,cAAcyC,aAAa5C,KAAK2B,WAAWe,GAAGvC,eAC3EwC,GACH3C,KAAKuC,WAAWb,KACd1B,KAAK4B,iBAAiBe,EAAOX,OAAQW,EAAOtD,MAAOsD,EAAOrD,OAAQ,IAAIM,EAAA,KAAM,IAAK,EAAG,Q,uCAM7EiD,GACfA,EAAMC,eACND,EAAME,gBACN,IAAMC,EAAYH,EAAMI,OAClBzD,EAAW,IAAIkB,EAAA,KACnBmC,EAAMK,MAAQF,EAAUG,WAAanD,KAAK8B,SAAS1B,EACnDyC,EAAMO,MAAQJ,EAAUK,UAAYrD,KAAK8B,SAASzB,GAEpDL,KAAKgB,cAAgBhB,KAAKsD,YAAY9D,GACtC,IAAM+D,EAAMvD,KAAKwD,cAAcR,GAC/BO,EAAIE,iBAAiB,YAAazD,KAAKiB,eAAeC,WACtDqC,EAAIE,iBAAiB,UAAWzD,KAAKiB,eAAeI,W,uCAGrCwB,GACfA,EAAMC,eACND,EAAME,gBACD/C,KAAKgB,eACRhB,KAAKgB,cAAcxB,SAASY,GAAKyC,EAAMa,UACvC1D,KAAKgB,cAAcxB,SAASa,GAAKwC,EAAMc,YAEvC3D,KAAK8B,SAAS1B,GAAKyC,EAAMa,UACzB1D,KAAK8B,SAASzB,GAAKwC,EAAMc,a,qCAIdd,GACbA,EAAMC,eACND,EAAME,gBACN,IAAMC,EAAYH,EAAMI,OACxBjD,KAAKgB,cAAgB,KACrB,IAAMuC,EAAMvD,KAAKwD,cAAcR,GAC/BO,EAAIK,oBAAoB,YAAa5D,KAAKiB,eAAeC,WACzDqC,EAAIK,oBAAoB,UAAW5D,KAAKiB,eAAeI,W,oCAG3CwC,GACZ,OAAGA,EAAGC,aAAeC,aAAqBF,EACnC7D,KAAKwD,cAAcK,EAAGG,c,kCAGnBxE,GACV,IAAI,IAAIiD,EAAIzC,KAAK2B,WAAWa,OAAO,EAAGC,GAAK,EAAGA,IAC5C,GAAGzC,KAAK2B,WAAWc,GAAGtC,cAAc8D,SAASzE,GAC3C,OAAOQ,KAAK2B,WAAWc,GAG3B,OAAO,O,iCAvFwB,OAAOzC,KAAKyB,QAAQ,K,iCACpB,OAAOzB,KAAKyB,QAAQ,O,GAVjByC,EAAA,MAqGvB,GACbC,MADa,WAEX,IAAMC,EAA2C,eAAI,MAE/CC,EAAa,IAAI,EAcvB,SAASC,EAAWxE,EAA8ByE,GAChDC,YAAYC,EAAQ,GACpBC,EAAK5E,EAAKyE,GAGZ,SAASE,IACPJ,EAAWI,OAAOhE,KAAKkE,MAAMC,YAAYC,OAAO,KAGlD,SAASH,EAAK5E,EAA8ByE,GAC1CO,EAAaP,GACbF,EAAWK,KAAKH,GAChBO,EAAahF,GACbA,EAAIiF,UAAUR,EAAOxC,OAAQ,EAAG,GAChCiD,uBAAsB,kBAAMN,EAAK5E,EAAKyE,MAGxC,SAASO,EAAahF,GACpBA,EAAImF,UAAU,EAAG,EAAGnF,EAAIiC,OAAO1C,MAAOS,EAAIiC,OAAOzC,QAGnD,SAASC,IACP,GAAI8E,EAAWvC,SAAf,CACA,IAAMzC,EAAQoB,KAAKkE,MAAoB,IAAdlE,KAAKyE,UAAc,GACtC5F,EAASmB,KAAKkE,MAAoB,IAAdlE,KAAKyE,UAAc,GACvCC,EAAYd,EAAWzC,iBAC3ByC,EAAWvC,SAASE,OACpB3C,EAAOC,EACPM,EAAA,KAAMC,iBAERwE,EAAW1C,WAAWD,KAAKyD,IAG7B,OA7CA,gBAAU,WACR,GAAIf,EAAegB,MAAnB,CACA,IAAMC,EAAcjB,EAAegB,MAAME,cAAc,UACjDf,EAASgB,SAASC,cAAc,UAAUC,WAAW,MAC3DlB,EAAOxC,OAAO1C,MAAQgG,EAAYhG,MAClCkF,EAAOxC,OAAOzC,OAAS+F,EAAY/F,OACnC,IAAMQ,EAAMuF,EAAYI,WAAW,MACnCpB,EAAWF,MAAMrE,GACjBsE,EAAegB,MAAM3B,iBAAiB,YAAaY,EAAWpD,eAAeM,WAC7E+C,EAAWxE,EAAKyE,OAoCX,CACLH,iBACA7E,mB,UChKN,EAAOmG,OAAS,EAChB,EAAOC,UAAY,kBAEJ","file":"js/chunk-13b84726.a762a687.js","sourcesContent":["export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./RectCollisionDemo.vue?vue&type=style&index=0&id=4b0a42e2&scoped=true&lang=scss\"","<template>\n  <div ref=\"game_container\" class=\"game-content mt-1\" >\n    <div class=\"game-controls\">\n      <button class=\"btn btn-secondary\" @click=\"new_rectangle\">Add Rectangle</button>\n    </div>\n    <div class=\"game-screen\">\n      <canvas width=\"640\" height=\"480\" />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\n\nimport GameWorld from '@/models/GameWorld';\nimport Point from '@/models/Point';\nimport Rect from '@/models/Rect';\nimport Color from '@/models/Color';\nimport Sprite from '@/models/Sprite';\nimport ScreenRect from '@/models/ScreenRect';\n\nimport { ref, onMounted, Ref } from 'vue';\n\nclass RectangleCollisionWorld extends GameWorld {\n\n  selected_rect: ScreenRect|null = null;\n  bound_handlers = {\n    mousemove: this.handle_mousemove.bind(this),\n    mouseup: this.handle_mouseup.bind(this),\n    mousedown: this.handle_mousedown.bind(this)\n  }\n\n  get rectangles(): ScreenRect[] { return this.sprites[0] as ScreenRect[]; }\n  get collisions(): ScreenRect[] { return this.sprites[1] as ScreenRect[]; }\n\n  setup(ctx:RenderingContext): void {\n    super.setup(ctx);\n    this.sprites.push([]);\n    this.sprites.push([]);\n    this.sprites.push([]);\n    this.rectangles.push(this.create_rectangle(new Point(-150, -120), 200, 200, new Color(0,255,0)));\n    this.rectangles.push(this.create_rectangle(new Point(100, 15), 180, 50, new Color(0,0,255)));\n    this.sprites[2].push(this.create_rectangle(Point.origin, 1, 1000, new Color(255, 255, 0, 0.5)));\n    this.sprites[2].push(this.create_rectangle(Point.origin, 1000, 1, new Color(255, 255, 0, 0.5)));\n    this.viewport = new Rect(\n      -ctx.canvas.width/2, \n      -ctx.canvas.height/2, \n      ctx.canvas.width,\n      ctx.canvas.height,\n    );\n  }\n\n  create_rectangle(center:Point, width:number, height:number, color:Color = Color.create_random()): ScreenRect {\n    const r = new ScreenRect(center.copy(), null, width, height, Rect.null_rect);\n    r.fill_color = color;\n    r.did_leave_bounding_box = ()=>{};\n    return r;\n  }\n\n  detect_collisions(dt:number) {\n    this.collisions.length = 0;\n    for(let i = 0; i < this.rectangles.length-1; i++)\n      for(let j = i+1; j < this.rectangles.length; j++) {\n        const c_rect = this.rectangles[i].collision_box.intersection(this.rectangles[j].collision_box);\n        if(!!c_rect) {\n          this.collisions.push(\n            this.create_rectangle(c_rect.center, c_rect.width, c_rect.height, new Color(255, 0, 0))\n          );\n        }\n      }\n  }\n\n  handle_mousedown(event:MouseEvent) {\n    event.preventDefault;\n    event.stopPropagation;\n    const container = event.target as HTMLElement;\n    const location = new Point(\n      event.pageX - container.offsetLeft + this.viewport.x,\n      event.pageY - container.offsetTop + this.viewport.y\n    );\n    this.selected_rect = this.get_rect_at(location);\n    const doc = this.get_root_node(container);\n    doc.addEventListener('mousemove', this.bound_handlers.mousemove);\n    doc.addEventListener('mouseup', this.bound_handlers.mouseup);\n  }\n\n  handle_mousemove(event:MouseEvent) {\n    event.preventDefault;\n    event.stopPropagation;\n    if(!!this.selected_rect) {\n      this.selected_rect.location.x += event.movementX;\n      this.selected_rect.location.y += event.movementY;\n    } else {\n      this.viewport.x -= event.movementX;\n      this.viewport.y -= event.movementY;\n    }\n  }\n\n  handle_mouseup(event:MouseEvent) {\n    event.preventDefault;\n    event.stopPropagation;\n    const container = event.target as HTMLElement;\n    this.selected_rect = null;\n    const doc = this.get_root_node(container);\n    doc.removeEventListener('mousemove', this.bound_handlers.mousemove);\n    doc.removeEventListener('mouseup', this.bound_handlers.mouseup);\n  }\n\n  get_root_node(el:HTMLElement): HTMLElement {\n    if(el.constructor == HTMLDocument) return el;\n    return this.get_root_node(el.parentNode as HTMLElement);\n  }\n\n  get_rect_at(location:Point): ScreenRect|null {\n    for(let i = this.rectangles.length-1; i >= 0; i--) {\n      if(this.rectangles[i].collision_box.contains(location)) {\n        return this.rectangles[i];\n      }\n    }\n    return null;\n  }\n\n}\n\nexport default {\n  setup() {\n    const game_container: Ref<HTMLDivElement|null> = ref(null);\n\n    const game_world = new RectangleCollisionWorld();\n\n    onMounted(()=>{\n      if(!game_container.value) return;\n      const game_canvas = game_container.value.querySelector('canvas') as HTMLCanvasElement;\n      const buffer = document.createElement('canvas').getContext('2d') as CanvasRenderingContext2D;\n      buffer.canvas.width = game_canvas.width;\n      buffer.canvas.height = game_canvas.height;\n      const ctx = game_canvas.getContext('2d') as CanvasRenderingContext2D;\n      game_world.setup(ctx);\n      game_container.value.addEventListener('mousedown', game_world.bound_handlers.mousedown);\n      start_game(ctx, buffer);\n    });\n\n    function start_game(ctx:CanvasRenderingContext2D, buffer:CanvasRenderingContext2D) {\n      setInterval(update, 0);\n      draw(ctx, buffer);\n    }\n\n    function update() {\n      game_world.update(Math.floor(performance.now())/1000);\n    }\n\n    function draw(ctx:CanvasRenderingContext2D, buffer:CanvasRenderingContext2D) {\n      clear_canvas(buffer);\n      game_world.draw(buffer);\n      clear_canvas(ctx);\n      ctx.drawImage(buffer.canvas, 0, 0);\n      requestAnimationFrame(() => draw(ctx, buffer));\n    }\n\n    function clear_canvas(ctx:CanvasRenderingContext2D): void {\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    }\n\n    function new_rectangle(): void {\n      if(!game_world.viewport) return;\n      const width = Math.floor(Math.random()*151)+50;\n      const height = Math.floor(Math.random()*151)+50;\n      const rectangle = game_world.create_rectangle(\n        game_world.viewport.center,\n        width, height,\n        Color.create_random()\n      )\n      game_world.rectangles.push(rectangle);\n    }\n\n    return {\n      game_container,\n      new_rectangle,\n    }\n  }\n}\n\n</script>\n\n<style scoped lang=\"scss\">\n\n.game-content {\n  width: fit-content;\n  margin: 0 auto;\n  user-select: none;\n}\n\ncanvas {\n  position: relative;\n  background-color: black;\n}\n\n</style>\n","import Sprite from '@/models/Sprite';\nimport Point from '@/models/Point';\nimport Rect from '@/models/Rect';\nimport Color from './Color';\n\nexport default class ScreenRect extends Sprite {\n  fill_color: Color = Color.create_random();\n  width: number;\n  height: number;\n\n  constructor(location:Point, velocity:Point|null, width:number, height:number, bounding_box:Rect) {\n    super(location, velocity, bounding_box);\n    this.width = width;\n    this.height = height;\n  }\n\n  get collision_box(): Rect {\n    return Rect.centered_at(this.location, this.width, this.height);\n  }\n\n  draw_sprite(ctx:CanvasRenderingContext2D): void {\n    ctx.fillStyle = this.fill_color.rgba;\n    ctx.fillRect(\n      this.collision_box.x,\n      this.collision_box.y,\n      this.collision_box.width, \n      this.collision_box.height\n    );\n  }\n\n  move_to(p: Point, speed: number = 1): this {\n    let atan2 = Math.atan2( \n      p.x - this.location.x,\n      p.y - this.location.y\n    );\n    this.velocity = new Point(\n      Math.sin(atan2)*speed, \n      Math.cos(atan2)*speed\n    );\n    return this;\n  }\n\n}\n\n","\n\nimport GameWorld from '@/models/GameWorld';\nimport Point from '@/models/Point';\nimport Rect from '@/models/Rect';\nimport Color from '@/models/Color';\nimport Sprite from '@/models/Sprite';\nimport ScreenRect from '@/models/ScreenRect';\n\nimport { ref, onMounted, Ref } from 'vue';\n\nclass RectangleCollisionWorld extends GameWorld {\n\n  selected_rect: ScreenRect|null = null;\n  bound_handlers = {\n    mousemove: this.handle_mousemove.bind(this),\n    mouseup: this.handle_mouseup.bind(this),\n    mousedown: this.handle_mousedown.bind(this)\n  }\n\n  get rectangles(): ScreenRect[] { return this.sprites[0] as ScreenRect[]; }\n  get collisions(): ScreenRect[] { return this.sprites[1] as ScreenRect[]; }\n\n  setup(ctx:RenderingContext): void {\n    super.setup(ctx);\n    this.sprites.push([]);\n    this.sprites.push([]);\n    this.sprites.push([]);\n    this.rectangles.push(this.create_rectangle(new Point(-150, -120), 200, 200, new Color(0,255,0)));\n    this.rectangles.push(this.create_rectangle(new Point(100, 15), 180, 50, new Color(0,0,255)));\n    this.sprites[2].push(this.create_rectangle(Point.origin, 1, 1000, new Color(255, 255, 0, 0.5)));\n    this.sprites[2].push(this.create_rectangle(Point.origin, 1000, 1, new Color(255, 255, 0, 0.5)));\n    this.viewport = new Rect(\n      -ctx.canvas.width/2, \n      -ctx.canvas.height/2, \n      ctx.canvas.width,\n      ctx.canvas.height,\n    );\n  }\n\n  create_rectangle(center:Point, width:number, height:number, color:Color = Color.create_random()): ScreenRect {\n    const r = new ScreenRect(center.copy(), null, width, height, Rect.null_rect);\n    r.fill_color = color;\n    r.did_leave_bounding_box = ()=>{};\n    return r;\n  }\n\n  detect_collisions(dt:number) {\n    this.collisions.length = 0;\n    for(let i = 0; i < this.rectangles.length-1; i++)\n      for(let j = i+1; j < this.rectangles.length; j++) {\n        const c_rect = this.rectangles[i].collision_box.intersection(this.rectangles[j].collision_box);\n        if(!!c_rect) {\n          this.collisions.push(\n            this.create_rectangle(c_rect.center, c_rect.width, c_rect.height, new Color(255, 0, 0))\n          );\n        }\n      }\n  }\n\n  handle_mousedown(event:MouseEvent) {\n    event.preventDefault;\n    event.stopPropagation;\n    const container = event.target as HTMLElement;\n    const location = new Point(\n      event.pageX - container.offsetLeft + this.viewport.x,\n      event.pageY - container.offsetTop + this.viewport.y\n    );\n    this.selected_rect = this.get_rect_at(location);\n    const doc = this.get_root_node(container);\n    doc.addEventListener('mousemove', this.bound_handlers.mousemove);\n    doc.addEventListener('mouseup', this.bound_handlers.mouseup);\n  }\n\n  handle_mousemove(event:MouseEvent) {\n    event.preventDefault;\n    event.stopPropagation;\n    if(!!this.selected_rect) {\n      this.selected_rect.location.x += event.movementX;\n      this.selected_rect.location.y += event.movementY;\n    } else {\n      this.viewport.x -= event.movementX;\n      this.viewport.y -= event.movementY;\n    }\n  }\n\n  handle_mouseup(event:MouseEvent) {\n    event.preventDefault;\n    event.stopPropagation;\n    const container = event.target as HTMLElement;\n    this.selected_rect = null;\n    const doc = this.get_root_node(container);\n    doc.removeEventListener('mousemove', this.bound_handlers.mousemove);\n    doc.removeEventListener('mouseup', this.bound_handlers.mouseup);\n  }\n\n  get_root_node(el:HTMLElement): HTMLElement {\n    if(el.constructor == HTMLDocument) return el;\n    return this.get_root_node(el.parentNode as HTMLElement);\n  }\n\n  get_rect_at(location:Point): ScreenRect|null {\n    for(let i = this.rectangles.length-1; i >= 0; i--) {\n      if(this.rectangles[i].collision_box.contains(location)) {\n        return this.rectangles[i];\n      }\n    }\n    return null;\n  }\n\n}\n\nexport default {\n  setup() {\n    const game_container: Ref<HTMLDivElement|null> = ref(null);\n\n    const game_world = new RectangleCollisionWorld();\n\n    onMounted(()=>{\n      if(!game_container.value) return;\n      const game_canvas = game_container.value.querySelector('canvas') as HTMLCanvasElement;\n      const buffer = document.createElement('canvas').getContext('2d') as CanvasRenderingContext2D;\n      buffer.canvas.width = game_canvas.width;\n      buffer.canvas.height = game_canvas.height;\n      const ctx = game_canvas.getContext('2d') as CanvasRenderingContext2D;\n      game_world.setup(ctx);\n      game_container.value.addEventListener('mousedown', game_world.bound_handlers.mousedown);\n      start_game(ctx, buffer);\n    });\n\n    function start_game(ctx:CanvasRenderingContext2D, buffer:CanvasRenderingContext2D) {\n      setInterval(update, 0);\n      draw(ctx, buffer);\n    }\n\n    function update() {\n      game_world.update(Math.floor(performance.now())/1000);\n    }\n\n    function draw(ctx:CanvasRenderingContext2D, buffer:CanvasRenderingContext2D) {\n      clear_canvas(buffer);\n      game_world.draw(buffer);\n      clear_canvas(ctx);\n      ctx.drawImage(buffer.canvas, 0, 0);\n      requestAnimationFrame(() => draw(ctx, buffer));\n    }\n\n    function clear_canvas(ctx:CanvasRenderingContext2D): void {\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    }\n\n    function new_rectangle(): void {\n      if(!game_world.viewport) return;\n      const width = Math.floor(Math.random()*151)+50;\n      const height = Math.floor(Math.random()*151)+50;\n      const rectangle = game_world.create_rectangle(\n        game_world.viewport.center,\n        width, height,\n        Color.create_random()\n      )\n      game_world.rectangles.push(rectangle);\n    }\n\n    return {\n      game_container,\n      new_rectangle,\n    }\n  }\n}\n\n","import { render } from \"./RectCollisionDemo.vue?vue&type=template&id=4b0a42e2&scoped=true&bindings={\\\"game_container\\\":\\\"setup\\\",\\\"new_rectangle\\\":\\\"setup\\\"}\"\nimport script from \"./RectCollisionDemo.vue?vue&type=script&lang=ts\"\nexport * from \"./RectCollisionDemo.vue?vue&type=script&lang=ts\"\n\nimport \"./RectCollisionDemo.vue?vue&type=style&index=0&id=4b0a42e2&scoped=true&lang=scss\"\nscript.render = render\nscript.__scopeId = \"data-v-4b0a42e2\"\n\nexport default script"],"sourceRoot":""}